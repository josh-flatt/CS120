# -*- coding: utf-8 -*-
"""cx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12NSr1ao6Dbwr3bKUP5Iq45U1_QHPhD7H
"""

'''
Functions for dealing with complex numbers as tuples
'''

from numpy import pi
pi = (pi, 0)

i = (0,1)

def cxsum(z1,z2):
  real = z1[0]+z2[0]
  imaginary = z1[1]+z2[1]
  return real,imaginary

def cxproduct(z1,z2):
  a = (z1[0]*z2[0])-(z1[1]*z2[1])
  b = (z1[0]*z2[1])+(z2[0]*z1[1])
  return a,b

def cxneg(z):
  a = -z[0]
  b = -z[1]
  return a,b

def cxpower(z,p):
  temp = [1,1]
  if p == 1:
    return z
  elif p > 1:
    return cxproduct(z,cxpower(z,p-1))

def cxmag(z):
    from numpy import sqrt
    return sqrt(z[0]**2 + z[1]**2)

def cxdiv(z1,z2):
  r = z2[0]**2 + z2[1]**2
  a = ((z1[0]*z2[0])+(z1[1]*z2[1]))/r
  b = ((z2[0]*z1[1])-(z1[0]*z2[1]))/r
  return a,b

def cxe(S, x):
    num = cxsum(S, cxneg(cxpower(x, 2)))
    den = cxproduct( (2, 0), x)
    return cxdiv(num, den)

def cxsqrt(S, x):
    count = 0
    er = cxe(S, x)
    while (cxmag(er)> 10**-15) and (count < 20):
        x = cxsum(x, er)
        er = cxe(S, x)
        count += 1
    return x, cxmag(er), count